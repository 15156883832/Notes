程序：指令和数据的有序集合

进程(process)：一段程序的执行过程，进程是一个实体，有自己的地址空间，进程是执行中的程序，进程有三种状态，就绪、运行和阻塞

线程(thread)：一个进程至少包含一个线程，资源分配的基本单位，独立运行和调度的基本单位

线程的几种状态：新建（new）、可运行(runnable)、运行(running)、等待阻塞(wait()方法，waiting queue)、同步阻塞(同步锁下等待)、其他阻塞(sleep():超时、join():终止超时 )、死亡（dead）

多线程：为了同步完成多项任务，不是为了提高运行效率，而是提高资源使用效率来提高系统的效率，一个线程死掉等于整个进程死掉，多进程的程序要比多线程的程序健壮，但是进程切换时耗费资源大


一个程序至少有一个进程，一个进程至少有一个线程。

创建线程的几种方式：（1）Thread类 （2）Runnable接口(常用，可以实现多继承，且线程池非常高效)（3）Callable接口

Thread.sleep(times):让出这个时间片段给其他线程执行，这个times时间过后在去执行，说白了就是推迟执行，但是不会释放锁

Thread.join():意思是等待该线程终止才能继续执行下面的代码

同步方法和同步代码块：使用关键字synchronized修饰方法（this或者当前类对象作为锁），同步代码块用sychronized(Object){代码块}来修饰，锁Object可以有我们自己来定义

监视器和锁：java中监视器和锁是一块使用的，监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块

死锁（deadLock）:多个进程因竞争资源二造成的僵局，若无外力则无法向前进行，进程A有某个资源a，但是执行过程中又要申请资源b,而b此时正在被进程B占用，而B又想申请资源a,两个进程都对自己所占用的进程保持不放，造成了死锁。

避免死锁的简单方法：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。

死锁产生的必要条件：（1）互斥条件：一段时间累该资源只能由一个进程占用；
		    （2）不剥夺条件，进程在未结束之前不能被其它进程所剥夺，只能主动释放；
		    （3）请求和保持条件：进程至少占用了一个资源，而又请求新的资源，而该资源又被其它进程所占用；
		    （4）循环等待条件：A等B，B等C,C等D,D等A	 

